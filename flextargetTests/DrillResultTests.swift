import XCTest
import CoreData
@testable import opencvtestminimal

final class DrillResultTests: XCTestCase {
    var container: NSPersistentContainer!

    override func setUpWithError() throws {
        try super.setUpWithError()
        container = NSPersistentContainer(name: "DrillDataModel")
        let desc = NSPersistentStoreDescription()
        desc.type = NSInMemoryStoreType
        container.persistentStoreDescriptions = [desc]

        let exp = expectation(description: "loadPersistentStores")
        container.loadPersistentStores { storeDesc, error in
            XCTAssertNil(error)
            exp.fulfill()
        }
        wait(for: [exp], timeout: 2.0)
    }

    override func tearDownWithError() throws {
        container = nil
        try super.tearDownWithError()
    }

    // Simple deterministic RNG (LCG) for repeatable tests
    struct SimpleRNG {
        var state: UInt64
        init(seed: UInt64) { state = seed }
        mutating func next() -> UInt64 {
            state = state &* 6364136223846793005 &+ 1442695040888963407
            return state
        }
        mutating func nextDouble() -> Double {
            return Double(next() & 0xFFFFFFFF) / Double(0xFFFFFFFF)
        }
        mutating func nextDouble(min: Double, max: Double) -> Double {
            return min + nextDouble() * (max - min)
        }
    }

    func testGenerateDrillWithThreeTargetTypes_andSaveShots() throws {
        let ctx = container.viewContext

        // Create DrillSetup
        let drillSetup = DrillSetup(context: ctx)
        drillSetup.id = UUID()
        drillSetup.name = "Unit Test Drill"
        drillSetup.desc = "Generated by test"
        drillSetup.delay = 0.0
        drillSetup.drillDuration = 60.0

        // Add three targets: hostage, rotation, paddle
        let types = ["hostage", "rotation", "paddle"]
        for (idx, t) in types.enumerated() {
            let tc = DrillTargetsConfig(context: ctx)
            tc.id = UUID()
            tc.targetType = t
            tc.targetName = "target_\(t)"
            tc.seqNo = Int16(idx + 1)
            tc.timeout = 10.0
            drillSetup.addToTargets(tc)
        }

        try ctx.save()

        // Deterministic RNG for time diffs and jitter
        var rng = SimpleRNG(seed: 123456789)

        var generatedShots: [ShotData] = []
        let shotsPerTarget = 5
        for target in types {
            for _ in 0..<shotsPerTarget {
                // Center around the center of a 720x1280 image with small deterministic jitter
                let centerX = 360.0 + rng.nextDouble(min: -20.0, max: 20.0)
                let centerY = 640.0 + rng.nextDouble(min: -20.0, max: 20.0)
                let timeDiff = rng.nextDouble(min: 0.2, max: 2.0)
                let content = Content(command: "shot", hitArea: "C", hitPosition: HitPosition(x: centerX, y: centerY), rotationAngle: 0, targetType: target, timeDiff: timeDiff, device: "device_\(target)")
                let shot = ShotData(target: nil, content: content, type: "shot", action: "hit", device: "device_\(target)")
                generatedShots.append(shot)
            }
        }

        // Create DrillResult and Shot entities and persist them (simulate app save)
        let drillResult = DrillResult(context: ctx)
        drillResult.drillId = drillSetup.id
        drillResult.date = Date()
        drillResult.drillSetup = drillSetup
        drillResult.totalTime = generatedShots.map { $0.content.timeDiff }.reduce(0, +)

        var cumulativeTime = 0.0
        let baseDate = Date()
        for sd in generatedShots {
            cumulativeTime += sd.content.timeDiff
            let shotEntity = Shot(context: ctx)
            let jsonData = try JSONEncoder().encode(sd)
            shotEntity.data = String(data: jsonData, encoding: .utf8)
            // Use cumulative time to derive a deterministic timestamp
            shotEntity.timestamp = Date(timeInterval: cumulativeTime, since: baseDate)
            shotEntity.drillResult = drillResult
        }

        try ctx.save()

        // Assertions
        let req: NSFetchRequest<DrillResult> = DrillResult.fetchRequest()
        req.predicate = NSPredicate(format: "drillId == %@", drillSetup.id! as CVarArg)
        let results = try ctx.fetch(req)
        XCTAssertEqual(results.count, 1, "Should have one DrillResult saved")
        guard let fetchedResult = results.first else {
            XCTFail("No fetched result")
            return
        }

        let shotCount = fetchedResult.shots?.count ?? 0
        XCTAssertEqual(shotCount, types.count * shotsPerTarget, "Shot count mismatch")

        // Decode shot JSON and verify distribution by targetType
        var countsByType: [String:Int] = [:]
        for case let shot as Shot in fetchedResult.shots ?? [] {
            if let dataStr = shot.data, let data = dataStr.data(using: .utf8) {
                let shotData = try JSONDecoder().decode(ShotData.self, from: data)
                countsByType[shotData.content.targetType, default: 0] += 1
            }
        }
        for t in types {
            XCTAssertEqual(countsByType[t], shotsPerTarget, "Shots for target \(t) mismatch")
        }

        // Verify totalTime stored matches sum of timeDiff
        let expectedTotal = generatedShots.map { $0.content.timeDiff }.reduce(0, +)
        XCTAssertEqual(fetchedResult.totalTime, expectedTotal, accuracy: 0.0001)
    }
}
